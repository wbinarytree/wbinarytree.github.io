<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>BinaryTree&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="BinaryTree's blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="BinaryTree's blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="BinaryTree's blog">
  
    <link rel="alternate" href="/atom.xml" title="BinaryTree&#39;s blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">BinaryTree&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-rxjava-3" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/09/rxjava-3/" class="article-date">
  <time datetime="2017-04-09T16:36:52.000Z" itemprop="datePublished">2017-04-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/09/rxjava-3/">拥抱RxJava（三）：关于Observable的冷热，常见的封装方式以及误区</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>前两篇文章 <a href="http://www.jianshu.com/p/61631134498e" target="_blank" rel="external">放弃RxBus，拥抱RxJava（一）：为什么避免使用EventBus/RxBus</a> ，<a href="http://www.jianshu.com/p/d2df6bceeff9" target="_blank" rel="external">放弃RxBus，拥抱RxJava（二）：Observable究竟如何封装数据？</a> 写了一堆理论。看起来并没有什么实际用处，那么今天。我们实战一下，来封装我们需要的数据，并且了解一下各种方式具体的区别。</p>
<blockquote>
<p>前言： 很多朋友误会我文章的意思。我写这个系列文章的意思主要是帮助了解一下RxJava的常见用法。而不是使用一下自己或别人封装好的RxBus就觉得自己的项目使用RxJava了。但是这也仅仅是个人口味问题，很多情况下确实RxBus/EventBus会很方便，很刺激，很上瘾。所以从这篇文章开始，我把标题中的”放弃RxBus”去除。</p>
</blockquote>
<p>无论在简书,微信平台,GitHub等等分享平台。一个名字上写着 “MVP(MVVM) + RxJava + Retrofit + Dagger2 + ……..”这样的名字，再熟悉不过了。然而，大多数情况进去看一下RxJava部分。要么就是简单的把取到的数据用<code>Observable.just()</code>直接传给下一层，要么就是直接使用Retrofit的Adapter来直接获得Observable，而app中其他部分并没有reactive。而且还有很多Observable用法错误，比如冷热不分，连续太多的Map/FlatMap等等。</p>
<h4 id="0-RxBus-Retrofit-足够用了，我为什么要让自己的App-更加的Reactive"><a href="#0-RxBus-Retrofit-足够用了，我为什么要让自己的App-更加的Reactive" class="headerlink" title="0. RxBus/Retrofit 足够用了，我为什么要让自己的App 更加的Reactive?"></a>0. RxBus/Retrofit 足够用了，我为什么要让自己的App 更加的Reactive?</h4><p>为什么不用RxBus我已经写了两篇文章了，可能由于我不常写文，很多人并没有理解。在这里我再解释一次：EventBus如果是一辆穿梭在所有代码之间的公交车。那么Observable就是穿梭在少许人之间的Uber专车。他比起EventBus有很多优势，比如异常处理，线程切换，强大的操作符等等。你当然可以做出一辆超级Uber来当全局公交车(RxBus)使用，然而这却损失了RxJava本来的许多优势，并且又给自己挖了许多坑。</p>
<h5 id="0-1-一个常见误区，过多的operator"><a href="#0-1-一个常见误区，过多的operator" class="headerlink" title="0.1 一个常见误区，过多的operator"></a>0.1 一个常见误区，过多的operator</h5><p>刚开始使用RxJava的时候，我们会觉得operator的链式调用会非常的爽，一个简单的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.just(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;)</div><div class="line">          .map(x -&gt; Integer.valueOf(x))</div><div class="line">          .map(x -&gt; x * 2)</div><div class="line">          .map(x -&gt; x + 4)</div><div class="line">          .filter(x -&gt; x &gt;2)</div><div class="line">          // and much more operators</div><div class="line">          .subscribeOn(Schedulers.io())</div><div class="line">          .observeOn(AndroidSchedulers.mainThread());</div></pre></td></tr></table></figure>
<p>当你只有很少数据的时候，这样当然可以，但是你数据量上来的时候，这就会有很多的overhead。 其实几乎所有的operator都会给你生成一个新的Observable。所以在上面这个例子中，我们在过程中生成了至少7个Observable。然而我们完全可以将中间的.map().map().map().filter合并在一个FlatMap中，减少很多的overhead。</p>
<h4 id="1-Observable-just-的局限性。"><a href="#1-Observable-just-的局限性。" class="headerlink" title="1. Observable.just()的局限性。"></a>1. Observable.just()的局限性。</h4><ol>
<li>使用<code>Observable.just()</code> 即使你没有调用subscribe方法。just()括号里面的代码也已经执行了。显然，<code>Observable.just()</code>不适合封装网络数据，因为我们通常不想在subscribe之前做网络请求。<br>举个例子：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">class TestClass&#123;</div><div class="line">  TestClass()&#123;</div><div class="line">    System.out.println(&quot;I&apos;m created!&quot;);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">Observable.just(new TestClass());</div></pre></td></tr></table></figure>
<p>这时你运行代码，你就看到确实你的TestClass 已经被创建了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">I/System.out: I&apos;m created!</div></pre></td></tr></table></figure>
<p> 当然，这个可以简单的用<code>defer()</code>/<code>fromCallable()</code>/<code>create()</code>操作符来是实现只有subscribe只有才加载。<br> 比如：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">// use fromCallable</div><div class="line">Observable.fromCallable(TestClass::new);</div><div class="line">//or</div><div class="line">Observable.defer(() -&gt; Observable.just(new TestClass()));</div></pre></td></tr></table></figure>
<ol>
<li>Observable.just()不够灵活。虽然说设计模式上我们追求 “Minimize Mutability” 但是如果我们的程序越来越 reactive的时候。一个 ObservableJust 往往是不满足需求的。比如之前一定订阅的subscriber。如果数据更新了，你不可以同过ObservableJust 来通知所有的Observable 新数据更新了，需要你的subscriber主动更新。这显然有悖于我们追求的reactive programming。 主动pull数据而不是数据告诉你，我更新了然后再做出反应。</li>
</ol>
<p>当然ObservableJust在很多情况下，确实不错。如果你不需要监听后续的更新，那么ObservableJust可以满足你的需求。</p>
<h4 id="2-Hot-Observable-和-cold-Observable"><a href="#2-Hot-Observable-和-cold-Observable" class="headerlink" title="2. Hot Observable 和 cold Observable"></a>2. Hot Observable 和 cold Observable</h4><p>很多人在封装数据的时候，并没有太多考虑冷热的问题，通常情况下并不会出错。因为目前很多开源项目(Demo)里除了RxBus,并没有太多的RxJava的实时情况。然而，当你的App越来越Reactive的时候，冷热便是一个必须考虑的问题。<br>Hot Observable 意思是如果他开始传输数据，你不主动喊停(<code>dispose()</code>/<code>cancel()</code>)，那么他就不会停，一直发射数据，即使他已经没有Subscriber了。而Cold Observable则是subscribe时才会发射数据。<br>然而，问题来了。我上篇文章讲过，只有subscribeActual方法调用了的时候，Observable发射数据，那为什么Hot Observable没有Subscriber也会发射数据，他把数据发射给谁了呢？我们在解决这个问题之前，先看一下Cold Observable:</p>
<h5 id="2-1-Cold-Observable"><a href="#2-1-Cold-Observable" class="headerlink" title="2.1 Cold Observable"></a>2.1 Cold Observable</h5><p>我们常见的工厂方法提供的都是ColdObservable,包括<code>just()</code>,<code>fromXX</code>,<code>create()</code>,<code>interval()</code>,<code>defer()</code>。 他们的共同点是当你有多个Subscriber的时候，他们的事件是独立的，举个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Observable interval = Observable.interval(1,TimeUnit.SECONDS);</div></pre></td></tr></table></figure>
<p>如果我们有两个subscriber,那么他们会各自有自己的计时器，并且互不干扰。效果如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2417399-72f4c48a5108c4d7.gif?imageMogr2/auto-orient/strip" alt=""></p>
<h5 id="2-2-Hot-Observable"><a href="#2-2-Hot-Observable" class="headerlink" title="2.2 Hot Observable"></a>2.2 Hot Observable</h5><p>不同于Cold Observable, Hot Observable是共享数据的。对于Hot Observable的所有subscriber,他们会在同一时刻收到相同的数据。我们通常使用<code>publish()</code>操作符来将ColdObservable变为Hot。或者我们在RxBus中常常用到的<code>Subjects</code> 也是Hot Observable。<br>刚刚我们刚刚提出了一个问题，</p>
<blockquote>
<p>既然Hot Observable在没有subscriber的时候，还会继续发送数据，那么数据究竟发给谁了呢？</p>
</blockquote>
<p>其实Hot Observable其实并没有发送数据，而是他上层的Observable 发送数据给这个hot Observable。不信？我们来分别看一下：</p>
<h6 id="2-2-1-ConnectableObservable"><a href="#2-2-1-ConnectableObservable" class="headerlink" title="2.2.1 ConnectableObservable"></a>2.2.1 ConnectableObservable</h6><p>我们在上面的误区中知道了，几乎所有operator都会生成一个新的Observable。publish当然不例外。但是有区别的是，publish会给你一个ConnectableObservable。具体实现类是ObservablePublish。这个Observable的区别是他提供一个<code>connect()</code>方法，如果你调用<code>connect()</code>方法，ConnectableObservable就会开始接收上游Observable的数据。我们来测试一下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">ConnectableObservable interval = Observable.interval(1, TimeUnit.SECONDS).publish();</div><div class="line">//connect even when no subscribers</div><div class="line">interval.connect();</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/2417399-144ff80f8b1010d9.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>果然，由于我们subscribe晚了一些。0这个数据没有收到，当我们两个 <code>Subscriber</code> <code>都dispose的时候，ConnectableObservable</code> 也仍在接受数据，导致我们6这个数据没有接收到。<br><code>ConnectableObservable</code> 其实在内部，有一个<code>PublishObserver</code>，他有两个作用。一个是当我们调用 <code>connect()</code>方法时， <code>PublishObserver</code>开始接受上游的数据，我们的例子里便是 <code>Observable.interval(1, TimeUnit.SECONDS)</code> 。所以才能在我们没有调用 <code>subscribe</code>方法时，他也能开始发送数据。第二个作用是 <code>PublishObserver</code>存储所有的下游Subscriber, 也就是我们例子中的Subscriber1 和Subscriber2，在 <code>PublishObserver</code> 每次接到一个上游数据，就会将接收到的结果，依次分发给他存储的所有 <code>Subscribers</code> ,如果下游 <code>Subscriber</code> 调用了 <code>dispose</code>方法，那么他就会在自己的缓存中删除这个 Subscriber，下次接受到上游数据便不会传给这个<code>Subscriber</code>。<br>那么这时候，有同学应该要问了：</p>
<blockquote>
<p>我们可不可以停止从上游接受数据？</p>
</blockquote>
<p>我们当然可以。但是从设计的角度，RxJava为了提供链式调用。 <code>connect()</code>方法会返回一个 Disposable 给我们来控制是否继续接受上游的数据。</p>
<h5 id="2-2-2-ConnectableObservable的常用操作符"><a href="#2-2-2-ConnectableObservable的常用操作符" class="headerlink" title="2.2.2 ConnectableObservable的常用操作符"></a>2.2.2 ConnectableObservable的常用操作符</h5><p>我们当然不希望每次都手动控制 <code>ConnectableObservable</code>的开关。RxJava给我们提供了一些常用的控制操作符</p>
<ol>
<li><p>refCount()<br><code>refCount()</code>可以说是最常用的操作符了。他会把 <code>ConnectableObservable</code>变为一个通常的Observable但又保持了HotObservable的特性。也就是说，如果出现第一个Subscriber,他就会自动调用 <code>connect()</code>方法，如果他开始接受之后，下游的 <code>Subscribers</code>全部dispose,那么他也会停止接受上游的数据。具体看图：<br><img src="http://upload-images.jianshu.io/upload_images/2417399-4d400a8bf1ffa3ea.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>每个 <code>Subscriber</code> 每次都会接受同样的数据，但是当所有 <code>subscriber</code> 都 dispose时候，他也会自动dipose上游的 <code>Observable</code> 。所以我们重新subscribe的时候，又重新从0开始。<br>这个操作符常用到，RxJava将他和publish合并为一个操作符 ：<code>share()</code>。</p>
</li>
<li><p>autoConnect()<br><code>autoConnect()</code>看名字就知道，他会自动链接，如果你单纯调用 <code>autoConnect()</code> ，那么，他会在你链接第一个 <code>Subscriber</code> 的时候调用 <code>connect()</code>，或者你调用 <code>autoConnect(int Num)</code>，那么他将会再收到Num个 <code>subscriber</code>的时候链接。<br>但是，这个操作符的关键在于，由于我们为了链式调用，autoConnect会返回Observable给你，你不会在返回方法里获得一个 <code>Disposable</code>来控制上游的开关。 不过没问题，autoConnect提供了另一种重载方法 ：<br><code>autoConnect(int numberOfSubscribers, Consumer&lt;? super Disposable&gt; connection)</code><br>他会在这个 <code>Consumer</code>传给你 你需要的那个总开关。而且，autoConnect并不会autoDisconnect, 也就是如果他即使没有subscriber了。他也会继续接受数据。</p>
</li>
<li>replay()<br><code>replay()</code>方法和 <code>publish()</code>一样，会返回一个 <code>ConnectableObservable</code>，区别是, <code>replay()</code>会为新的subscriber重放他之前所收到的上游数据，我们再来举个例子：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">  //only replay 3 values</div><div class="line">Observable.interval(1, TimeUnit.SECONDS).replay(3).refCount();</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/2417399-c0b0fde9b0c67894.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>果然，Subscriber2在subscribe时候，立即收到了之前已经错过的三个数据，然后继续接受后面的数据。<br>但是，这里有几点需要考虑：replay() 会缓存上游发过来的数据，所以并不需要担心重新生成新数据给新的 Subscriber。</p>
<ol>
<li>ReplayingShare()<br>其实ReplayingShare并不能算是ConnectableObservable的一个操作符，他是JakeWhaton的一个开源库，只有百来行。实现的功能是几乎和<code>replay(1).refCount()</code>差不多。但是如果中断 Conncection之后，重新开始subscribe,他仍然会给你一个重放他上一次的结果。 具体看图：<br><img src="http://upload-images.jianshu.io/upload_images/2417399-5de2bcd0d3aca667.gif?imageMogr2/auto-orient/strip" alt=""><br>我们看到和刚才的replay不同，即使两个Subscriber都 dispose, 重新开始仍然会接收到我们缓存过的一个数据。</li>
</ol>
<h5 id="2-3-Subjects"><a href="#2-3-Subjects" class="headerlink" title="2.3 Subjects"></a>2.3 Subjects</h5><p>Subjects 作为一个Reactive世界中的特殊存在，他特殊在于他自己既是一个Observable又是一个Observer(Subscriber)。你既可以像普通Observable一样让别的Subscriber来订阅，也可以用Subjects来订阅别人。更方便的是他甚至暴露了OnXX(),方法给你。你直接调用可以通知所有的Subscriber。 这也是RxBus的基础，RxBus几乎离不开Subjects。 蜘蛛侠的老爹告诉我们，力量越大，责任就也大。Subjects也一样。 Subjects因为暴露了OnXX()方法，使得Subjects的数据来源变得难以控制。而且，Subjects一直是HotObservable，我们来看下Subject的<code>OnNext()</code>方法的实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onNext(T t) &#123;</div><div class="line">    if (subscribers.get() == TERMINATED) &#123;</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    if (t == null) &#123;</div><div class="line">        onError(new NullPointerException(&quot;onNext called with null. Null values are generally not allowed in 2.x operators and sources.&quot;));</div><div class="line">        return;</div><div class="line">    &#125;</div><div class="line">    for (PublishDisposable&lt;T&gt; s : subscribers.get()) &#123;</div><div class="line">        s.onNext(t);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>可以看出来Subjects只要调用了<code>OnNext()</code>方法就会立即发送数据。所以，使用时一定要注意Subjects和Subscriber的链接时序问题。具体Subjects的用法我想介绍帖子已经足够多了。这里就不赘述了。</p>
<h4 id="3-在Android中常见的几种封装和注意事项"><a href="#3-在Android中常见的几种封装和注意事项" class="headerlink" title="3. 在Android中常见的几种封装和注意事项"></a>3. 在Android中常见的几种封装和注意事项</h4><h5 id="1-封装View-的Listener"><a href="#1-封装View-的Listener" class="headerlink" title="1.封装View 的Listener"></a>1.封装View 的Listener</h5><p>View 的各种Listener 我们常用create方法来封装，比如OnClickListener:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Observable.create(emitter -&gt; &#123;</div><div class="line">    button.setOnClickListener(v -&gt; emitter.onNext(&quot;I&apos;m Clicked&quot;));</div><div class="line">    emitter.setCancellable(() -&gt; button.setOnClickListener(null));</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>这里非常关键的一点是一定要设置解除绑定，否则你将持续使用这个会造成内存泄漏。而且最好配合使用share()。否则只有最后一个Subscriber能收到OnClick。当然，如果不考虑方法数的话，推荐配合使用RxBinding。</p>
<p>而且，用create()方法封装Listener适合几乎所有的callback, 并且安全。</p>
<h5 id="2-封装简单的数据源"><a href="#2-封装简单的数据源" class="headerlink" title="2.封装简单的数据源"></a>2.封装简单的数据源</h5><p>设想一个场景，我们有一个User类。里面有我们的用户名，头像，各种信息。然而在我们的app中，可能有三四个Fragment/Activity需要根据这个User做出不同的反应。这时我们就可以简单的使用Subject来封装User类。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public class UserRepository &#123;</div><div class="line">    private User actualUser;</div><div class="line"></div><div class="line">    private Subject&lt;User&gt; subject = ReplaySubject.createWithSize(1);</div><div class="line"></div><div class="line">    /**</div><div class="line">     *</div><div class="line">     *Get User Data from wherever you want Network/Database etc</div><div class="line">     */</div><div class="line"></div><div class="line">    public Observable&lt;User&gt; getUpdate()&#123;</div><div class="line">        return subject;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public void updateUser(User user)&#123;</div><div class="line">        actualUser = user;</div><div class="line">        subject.onNext(actualUser);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们某些模块需要这个User,那么只需要subscribe到这个Repository，如果User有更新，每一个Subscriber都会收到更新后的User并且互相不影响。而且我们使用ReplaySubject,即使有新的Subscriber，也会收到最新的一个Subject。<br>但是使用的时候一定要注意，因为用的是Subject.所以在onNext方法中一旦出现了error。那么所有的Subscriber都将和这个subject断开了链接。这里也可以用RxRelay代替Subject，简单来说Relay就是一个没有onError和onComplete的Subject。</p>
<h5 id="3-简单的使用concat-first-来处理多来源"><a href="#3-简单的使用concat-first-来处理多来源" class="headerlink" title="3.简单的使用concat().first()来处理多来源"></a>3.简单的使用concat().first()来处理多来源</h5><p>Dan Lew在他的博客<a href="http://blog.danlew.net/2015/06/22/loading-data-from-multiple-sources-with-rxjava/" target="_blank" rel="external">Loading data from multiple sources with RxJava
</a>中介绍过他这种处理方法，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">// Our sources (left as an exercise for the reader)</div><div class="line">Observable&lt;Data&gt; memory = ...;  </div><div class="line">Observable&lt;Data&gt; disk = ...;  </div><div class="line">Observable&lt;Data&gt; network = ...;</div><div class="line"></div><div class="line">// Retrieve the first source with data</div><div class="line">Observable&lt;Data&gt; source = Observable  </div><div class="line">  .concat(memory, disk, network)</div><div class="line">  .first();</div></pre></td></tr></table></figure>
<p>然后在每次做不同请求的时候刷新缓存</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Data&gt; networkWithSave = network.doOnNext(data -&gt; &#123;  </div><div class="line">  saveToDisk(data);</div><div class="line">  cacheInMemory(data);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">Observable&lt;Data&gt; diskWithCache = disk.doOnNext(data -&gt; &#123;  </div><div class="line">  cacheInMemory(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>具体也可以看这篇简书，我也不在过多赘述 <a href="http://www.jianshu.com/p/d5c43a10250b" target="_blank" rel="external">：RxJava（八）concat符操作处理多数据源</a></p>
<h5 id="4-自己继承Observable-手动写subscribeActual-方法"><a href="#4-自己继承Observable-手动写subscribeActual-方法" class="headerlink" title="4.自己继承Observable 手动写subscribeActual()方法"></a>4.自己继承Observable 手动写subscribeActual()方法</h5><p>这可能是最灵活的写法？如果你想用RxJava封装自己的库，推荐这种方法封装。因为这样不仅仅可以有效的进行错误处理，并且不会暴露过多逻辑给外面，许多优秀的RxJava相关库都是这样封装，就连RxJava自己也是把一个个的operator封装成一个个不同的Observable。但是这种方法确实要求很高，要做很多考虑，比如异步，多线程冲突，错误处理。对新手不是很推荐。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/09/rxjava-3/" data-id="cj1ax1gh0000060w17ciafpkd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RxJava/">RxJava</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-rxjava-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/09/rxjava-2/" class="article-date">
  <time datetime="2017-04-09T16:32:37.000Z" itemprop="datePublished">2017-04-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/09/rxjava-2/">放弃RxBus，拥抱RxJava（二）：Observable究竟如何封装数据？</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上篇简单讲到了一些关于<em>Event/Rx bus</em>的优缺点。并且提到了如何“正确”使用RxJava，而不是使用RxBus来自己重新发明轮子。</p>
<blockquote>
<p><a href="https://wbinarytree.github.io/2017/04/09/RxJava-1/" target="_blank" rel="external">放弃RxBus，拥抱RxJava（一）：为什么避免使用EventBus/RxBus</a></p>
</blockquote>
<p>其中也讲到了一个简单使用 <em>create()</em> 方法来进行封装Observable。但也留下了许多坑，比如内存泄漏，不能Multicast(多个Subscriber订阅同一个Observable) 等问题。所以这篇，我们接着通过这个例子，来具体了解下，如何封装Observable。</p>
<h4 id="1-Observable提供的静态方法都做了什么？"><a href="#1-Observable提供的静态方法都做了什么？" class="headerlink" title="1. Observable提供的静态方法都做了什么？"></a>1. Observable提供的静态方法都做了什么？</h4><p>首先我们来简单看一下Observable的静态方法，just/from/create都怎么为你提供Observable。<br>我们先看just:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">public static &lt;T&gt; Observable&lt;T&gt; just(T item) &#123;</div><div class="line">    ObjectHelper.requireNonNull(item, &quot;The item is null&quot;);</div><div class="line">    return RxJavaPlugins.onAssembly(new ObservableJust&lt;T&gt;(item));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们暂时不需要纠结 RxJavaPlugins.onAssembly() 这个方法。比较重要的是 just(T item) 方法会为你提供一个 ObservableJust<t>(item) 的实例，而这个 ObservableJust 类，就是一个RxJava内部的实现类。<br>在 RxJava 2.x 中 Observable 是一个抽象类,只有一个抽象方法，subscribeActual(Observer observer);（但是Observable的源码足足有13518行！！！）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public abstract class Observable&lt;T&gt; implements ObservableSource&lt;T&gt;&#123;</div><div class="line">  //implemented methods</div><div class="line"></div><div class="line">  protected abstract void subscribeActual(Observer&lt;? super T&gt; observer);</div><div class="line"></div><div class="line">  //other implements/operators</div><div class="line">&#125;</div></pre></td></tr></table></figure></t></p>
<p>那么ObservableJust这个类究竟什么样呢？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public final class ObservableJust&lt;T&gt; extends Observable&lt;T&gt; implements ScalarCallable&lt;T&gt; &#123;</div><div class="line"></div><div class="line">    private final T value;</div><div class="line">    public ObservableJust(final T value) &#123;</div><div class="line">        this.value = value;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    protected void subscribeActual(Observer&lt;? super T&gt; s) &#123;</div><div class="line">        ScalarDisposable&lt;T&gt; sd = new ScalarDisposable&lt;T&gt;(s, value);</div><div class="line">        s.onSubscribe(sd);</div><div class="line">        sd.run();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    @Override</div><div class="line">    public T call() &#123;</div><div class="line">        return value;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们首先看到构造方法里，直接把value赋给了ObservableJust的成员。这也就是为什么Observable.just()里的代码会直接运行，而不是像create()方法，有Subscriber时候才能运行。<br>再来看看两个item的just(T item1,T item2):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">public static &lt;T&gt; Observable&lt;T&gt; just(T item1, T item2) &#123;</div><div class="line">    ObjectHelper.requireNonNull(item1, &quot;The first item is null&quot;);</div><div class="line">    ObjectHelper.requireNonNull(item2, &quot;The second item is null&quot;);</div><div class="line"></div><div class="line">    return fromArray(item1, item2);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>诶？怎么画风突变？不是ObservableJust了？其实除了只有一个item的just,其他的just方法也都是调用了这个fromArray。那我们来看看这个fromArray:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">public static &lt;T&gt; Observable&lt;T&gt; fromArray(T... items) &#123;</div><div class="line">    ObjectHelper.requireNonNull(items, &quot;items is null&quot;);</div><div class="line">    if (items.length == 0) &#123;</div><div class="line">        return empty();</div><div class="line">    &#125; else</div><div class="line">    if (items.length == 1) &#123;</div><div class="line">        return just(items[0]);</div><div class="line">    &#125;</div><div class="line">    return RxJavaPlugins.onAssembly(new ObservableFromArray&lt;T&gt;(items));</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>前面一些check我们忽略，这里我们发现一些熟悉的身影了ObservableFromArray<t>(items)。又一个Observable的实现类。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">public final class ObservableFromArray&lt;T&gt; extends Observable&lt;T&gt; &#123;</div><div class="line">    final T[] array;</div><div class="line">    public ObservableFromArray(T[] array) &#123;</div><div class="line">        this.array = array;</div><div class="line">    &#125;</div><div class="line">    @Override</div><div class="line">    public void subscribeActual(Observer&lt;? super T&gt; s) &#123;</div><div class="line">        FromArrayDisposable&lt;T&gt; d = new FromArrayDisposable&lt;T&gt;(s, array);</div><div class="line"></div><div class="line">        s.onSubscribe(d);</div><div class="line"></div><div class="line">        if (d.fusionMode) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        d.run();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    static final class FromArrayDisposable&lt;T&gt; extends BasicQueueDisposable&lt;T&gt; &#123;</div><div class="line">      //implements</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></t></p>
<p>是不是更熟悉？其实Observable几乎所有的静态方法都是这样，甚至包括一些著名的RxJava库比如RxBinding,也都是使用这种封装方法。内部实现Observable的subscribeActual()方法。对外只提供静态方法来为你生成Observable。为什么这么做，我们来了解一下subscribeActual()方法。</p>
<h4 id="2-subscribeActual-究竟是什么？"><a href="#2-subscribeActual-究竟是什么？" class="headerlink" title="2. subscribeActual() 究竟是什么？"></a>2. subscribeActual() 究竟是什么？</h4><p>subscribeActual()其实就是Observable和Observer沟通的桥梁。这个Observer(Subscriber)就是你在Observable.subscribe()方法里写的那个类，或者是Consumer(只处理onNext方法)。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public final void subscribe(Observer&lt;? super T&gt; observer) &#123;</div><div class="line">    ObjectHelper.requireNonNull(observer, &quot;observer is null&quot;);</div><div class="line">    try &#123;</div><div class="line">        observer = RxJavaPlugins.onSubscribe(this, observer);</div><div class="line"></div><div class="line">        ObjectHelper.requireNonNull(observer, &quot;Plugin returned null Observer&quot;);</div><div class="line"></div><div class="line">        subscribeActual(observer);</div><div class="line">    &#125; catch (NullPointerException e) &#123; // NOPMD</div><div class="line">    &#125; catch (Throwable e) &#123;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们看到其实这个方法除了Check和Apply就只有这一行subscribeActual(observer)，连接了Observable和Observer。所以我们知道了，subscribeActual()方法里的代码，只有在subscribe()调用后，才回调用。</p>
<p>那么他们是如何链接的呢？其实很简单，根据你的逻辑一句一句的调用observer.onXX()方法就可以了。比如刚才我们看到的ObservableJust:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void run() &#123;</div><div class="line">    if (get() == START &amp;&amp; compareAndSet(START, ON_NEXT)) &#123;</div><div class="line">        observer.onNext(value);</div><div class="line">        if (get() == ON_NEXT) &#123;</div><div class="line">            lazySet(ON_COMPLETE);</div><div class="line">            observer.onComplete();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>再比如我们的ObservableFromArray:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">void run() &#123;</div><div class="line">    T[] a = array;</div><div class="line">    int n = a.length;</div><div class="line"></div><div class="line">    for (int i = 0; i &lt; n &amp;&amp; !isDisposed(); i++) &#123;</div><div class="line">        T value = a[i];</div><div class="line">        if (value == null) &#123;</div><div class="line">            actual.onError(new NullPointerException(&quot;The &quot; + i + &quot;th element is null&quot;));</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        actual.onNext(value);</div><div class="line">    &#125;</div><div class="line">    if (!isDisposed()) &#123;</div><div class="line">        actual.onComplete();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>复杂点的例子，比如如何封装button的OnClick事件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">@Override protected void subscribeActual(Observer&lt;? super Object&gt; observer) &#123;</div><div class="line">  if (!checkMainThread(observer)) &#123;</div><div class="line">    return;</div><div class="line">  &#125;</div><div class="line">  Listener listener = new Listener(view, observer);</div><div class="line">  observer.onSubscribe(listener);</div><div class="line">  view.setOnClickListener(listener);</div><div class="line">&#125;</div><div class="line"></div><div class="line">static final class Listener extends MainThreadDisposable implements OnClickListener &#123;</div><div class="line">  private final View view;</div><div class="line">  private final Observer&lt;? super Object&gt; observer;</div><div class="line"></div><div class="line">  Listener(View view, Observer&lt;? super Object&gt; observer) &#123;</div><div class="line">    this.view = view;</div><div class="line">    this.observer = observer;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override public void onClick(View v) &#123;</div><div class="line">    if (!isDisposed()) &#123;</div><div class="line">      observer.onNext(Notification.INSTANCE);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  @Override protected void onDispose() &#123;</div><div class="line">    view.setOnClickListener(null);</div><div class="line">  &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>但是细心的同学应该看到了，每个subscribeActual()方法里，都会有  observer.onSubscribe(disposable)这句。那么这句又是做什么的呢？<br>Disposable其实就是控制你取消订阅的。他只有两个方法 dispose() 取消订阅，和 isDisposed() 来通知是否已经取消了订阅。<br>取消订阅时，要根据需求释放资源。在subscribeActual()里逻辑要严谨，比如onComplete()之后不要有onNext()。需要注意的点很多，所以可能这也就是为什么RxJava推荐用户使用静态方法生成Observable吧。</p>
<p>最后再说一下几点：</p>
<ul>
<li>create()方法：其实create()方法相当于你把subscribeActual中的代码，写到了create里而已。所以有很高的操控性。</li>
<li>Flowable:Floawble其实在实现上和Observable类似，区别是Observable同过 Disposable控制取消订阅。而Flowable同过Subscription。其中还需要request()方法控制流量。具体关于这个问题，我推荐这篇文章<blockquote>
<p><a href="http://www.jianshu.com/p/36e0f7f43a51" target="_blank" rel="external">给初学者的RxJava2.0教程</a></p>
</blockquote>
</li>
</ul>
<p>总结：</p>
<ul>
<li>我们从源码分析角度来说，RxJava 2.x 也是同过subscribeActual来链接Observable和Observer(Subscriber)。本质上和Listener没什么太大区别。但是，RxJava的确是诸多一线Java/Android开发者的结晶。丰富的操作符，线程调度等等诸多优势。而且保证类型安全。<br>如果你还是停留在仅仅使用RxJava来实现一个RxBus，是不是有点杀鸡用牛刀呢？</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/09/rxjava-2/" data-id="cj1ax1gh9000360w1zbzjz5na" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RxJava/">RxJava</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-RxJava-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/04/09/RxJava-1/" class="article-date">
  <time datetime="2017-04-09T16:25:56.000Z" itemprop="datePublished">2017-04-09</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/04/09/RxJava-1/">放弃RxBus，拥抱RxJava（一）：为什么避免使用EventBus/RxBus</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>EventBus和Otto在之前作为Android组件间通信工具，简单方便十分受欢迎，但是也非常容易Abuse。大概有如下几个缺点：</p>
<ul>
<li>由于是Event,在发布Event的时候就要做好准备可能并没有人接受这个Event, Subscribe的时候也要做好准备可能永远不会收到Event。Event无论顺序还是时间上都某种程度上不太可控。如果你将数据寄托在Event上然后就直接在Android其他生命周期方法中直接使用这个数据或成员变量。那么很有可能你会得到NPE。</li>
<li>EventBus看似将你的程序解耦，但是又有些过了。我们常常使用EventBus传数据，这已经是Dependency级别的数据而不是一个可以被解耦出来的模块。这样就造成了过多EventBus的代码会造成代码结构混乱，难以测试和追踪，违背了解耦的初衷。这时如果有意或无意的造成了Nested Event。那情况会更糟。</li>
</ul>
<p>由于EventBus的种种缺点，以及后面RxJava的出现。很多人都开始使用RxJava来取代EventBus。甚至Otto的官方介绍里都写到：</p>
<blockquote>
<h2 id="Deprecated"><a href="#Deprecated" class="headerlink" title="Deprecated!"></a>Deprecated!</h2><p>This project is deprecated in favor of <a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava</a> and<br><a href="https://github.com/ReactiveX/RxAndroid" target="_blank" rel="external">RxAndroid</a>. These projects permit the same event-driven<br>programming model as Otto, but they’re more capable and offer better control of threading.</p>
<p>If you’re looking for guidance on migrating from Otto to Rx, <a href="http://blog.kaush.co/2014/12/24/implementing-an-event-bus-with-rxjava-rxbus/" target="_blank" rel="external">this post</a><br>is a good start.</p>
</blockquote>
<p>链接是一个教你怎么使用RxJava来自己手动写一个RxBus来代替EventBus的文章。虽然看起来是在用RxJava。但是实际上却仍然在用EventBus。甚至这个封装其实也并没有GreenRobot或者Otto来的好。<br>我们看看Jake Wharton对RxBus的评价：<br><img src="http://upload-images.jianshu.io/upload_images/2417399-ef00941c1cfd7ace.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br><em>我想”RxBus”唯一的好处就是他是一个Rx的入门毒品。否则的话，你要么就不是在用Rx，要么你需要更加惯用的Rx资源</em> (渣翻译见谅)</p>
<p>再来一个GitHub的：<br><img src="http://upload-images.jianshu.io/upload_images/2417399-7608f7d805c23783.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>subscribeActual部分我们先不考虑。然而Jake指出最好不要使用Relay来“重新发明”Event Bus.</p>
<p>这里看图说话：<br>Jake Wharton在GOTO 2016 上的讲座中提到，我们正常的Android编程是这样的：<br><img src="http://upload-images.jianshu.io/upload_images/2417399-5612eee4ee9a61d2.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>我们像一个中间人一样。<br>而使用RxJava。 我们的结构，更像这样<br><img src="http://upload-images.jianshu.io/upload_images/2417399-00cf6db34e8b4c84.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>我们使用RxJava来直接把组件相连，对所接受到的数据作出反应，所谓的 “Reactive”。<br>而使用Eventbus? Jake 没说， 我自己画一个：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2417399-6da08e095b8d0899.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""><br>我们作为一个中间人，传递消息。EventBus作为另一个中间人。帮我们传递消息。（这也就是所谓的“看似解耦”）</p>
<p>再打个比方，虽然我们将EventBus翻译成时间总线，但是其实总线就是Bus也就是公交车。而RxJava更像一个专车，Uber或者滴滴。他直接链接你的两个或多个需要通信的类。传输数据，当然你可以做一个很大的专车，穿梭在所有类之间，也就是所谓的RxBus。所以在这里为什么放弃RxBus也就不言而喻了不是？</p>
<p>那么，问题来了？</p>
<h4 id="怎样才是正确（正常？）的RxJava使用方式？"><a href="#怎样才是正确（正常？）的RxJava使用方式？" class="headerlink" title="怎样才是正确（正常？）的RxJava使用方式？"></a>怎样才是正确（正常？）的RxJava使用方式？</h4><p>其实Jake 也在GitHub的讨论上给出了一个答案：<br><img src="http://upload-images.jianshu.io/upload_images/2417399-379766ad920c95ee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>所以应该是，每当你想发布一个Event在EventBus时，直接暴露一个Observable出来。每当你想接受一个Event时，找到这个Observable并且Subscribe他。</p>
<p>这样做的好处是什么？</p>
<ul>
<li>目标和地点都很明确。你的Subscriber明确的知道他Subscribe的是谁，而且明确的知道我需要作出什么反应。这也正是RxJava的核心“响应式编程”。</li>
<li>由于使用了Observable,对于异常处理将会非常方便。而且还有功能强大全面的Operator来辅助你。</li>
<li>虽然看起来耦合性有所增加。但是这是必要的，上面也说过，EventBus虽然在代码上看似解耦。其实他们还是联系在一起的。而我们这样直接暴露Observable给需要的其他类，这完成了1 -&gt; 1/N的链接，而不需要EventBus这个中间人来传递消息/事件，而且保证我们需要的事件一定会直接到达。</li>
</ul>
<p>####我们来举个例子</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2417399-810562495275f259.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p>
<p>上下两个Fragment，上面的一个EditText，下面的一个TextView。上面的EditText变化的时候下面的TextView也跟着变化。</p>
<p>先把EditText的TextChangedListener封装在Observable里：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">        stringObservable = Observable.create(e -&gt; editText.addTextChangedListener(new TextWatcher() &#123;</div><div class="line">            @Override</div><div class="line">            public void beforeTextChanged(CharSequence s, int start, int count, int after) &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void onTextChanged(CharSequence s, int start, int before, int count) &#123;</div><div class="line">                e.onNext(s.toString());</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void afterTextChanged(Editable s) &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;));</div><div class="line"></div><div class="line">/**</div><div class="line">***</div><div class="line">*/</div><div class="line">    //Expose Observable</div><div class="line">    public Observable&lt;String&gt; getEditTextObservable() &#123;</div><div class="line">        return stringObservable;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>不习惯自己封装可以使用RxBinding :<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">stringObservable = RxTextView.textChangeEvents(editText)</div><div class="line">                             .map(event -&gt; event.text().toString());</div></pre></td></tr></table></figure></p>
<p>再从我们的TextViewFragment中 取到这个封装好的Observable:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@Override</div><div class="line">public void onStart() &#123;</div><div class="line">    super.onStart();</div><div class="line">    FragmentEditText fragment = (FragmentEditText) getFragmentManager().findFragmentByTag(FragmentEditText.TAG);</div><div class="line">    if(fragment != null)&#123;</div><div class="line">        fragment.getStringObservable().subscribe(s -&gt; textView.setText(s));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>来看看效果：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2417399-f008642da01d310f.gif?imageMogr2/auto-orient/strip" alt=""></p>
<p>当然，这里还有个问题</p>
<ul>
<li>由于我们将editText封装在Observable里，无论是create()方法还是使用RxBinding，都会持有这个View的强引用。造成内存泄漏。所以我们一定要在最后加入dispose()方法来释放。所以我推荐使用RxBinding，他已经帮我们在dispose()方法里写好了解除Listener的方法。</li>
<li>因为并没有使用publish操作符，导致多个Subscriber的时候还是有些许问题。可以考虑直接加入.share().</li>
</ul>
<p>具体我们如何讲常用的数据/Callback封装到Observable中。我会在接下来的文章中写到。</p>
<blockquote>
<p> <a href="https://wbinarytree.github.io/2017/04/09/rxjava-2/" target="_blank" rel="external">第二篇链接</a></p>
</blockquote>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/04/09/RxJava-1/" data-id="cj1ax1gh4000160w1l44cgd69" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/RxJava/">RxJava</a></li></ul>

    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RxJava/">RxJava</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 10px;">Android</a> <a href="/tags/RxJava/" style="font-size: 10px;">RxJava</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/04/09/rxjava-3/">拥抱RxJava（三）：关于Observable的冷热，常见的封装方式以及误区</a>
          </li>
        
          <li>
            <a href="/2017/04/09/rxjava-2/">放弃RxBus，拥抱RxJava（二）：Observable究竟如何封装数据？</a>
          </li>
        
          <li>
            <a href="/2017/04/09/RxJava-1/">放弃RxBus，拥抱RxJava（一）：为什么避免使用EventBus/RxBus</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 BinaryTree WANG<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>